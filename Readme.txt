Program Structure:
   The system has ten people, with their friend and book information supplied by the person.txt file. There’re a total of 74 books, dispersed among ten people. When a person wants to borrow a book, they can request it by title, author, topic, or their own annotation. The borrow() method in the Person class uses BFS to make sure the person asks her immediate friends first. If none of the immediate friends have that book, she then go on to ask the friends of friends.
   When a person successfully borrows a book, she will give this book a rating. The book’s average rating will be updated and displayed. The borrower will also randomly decide whether to annotate the book or not. If the book has already been annotated, she won’t be able to annotate it again. Thus I distinguished between “does not want to annotate” and “wants to but cannot annotate.”
   In the List class, I created an iterator to allow the use of “for” loop, such as “for person in personlist: ” There is also the index(self,num) method, which returns data in the indexed node. When I want to use the list as a queue, I use the append() and pop() method, and I do not see a need to create a separate Queue class. The mergesort method allows sorting according to different attributes.
   In the main file, books and people objects are initialized from imported file. Then everyone gets to borrow one book per round. A function randomly generates whether a person wants to find book by title, author, or topic, then the function gives the relevant information of a random book, to feed into the borrow method in Person class.
   I used mergesort to sort the population and the library by different attributes, mergesort’s efficiency is good. 
